(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{644:function(v,_,r){"use strict";r.r(_);var a=r(3),t=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"交换机类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#交换机类型"}},[v._v("#")]),v._v(" 交换机类型")]),v._v(" "),_("ul",[_("li",[v._v("default（默认交换机）：系统内置交换机，名字为"),_("code",[v._v('""')]),v._v("，所有队列不指定绑定交换机的情况下默认都是绑定在该交换机上，并且会为绑定创建一个路由键（"),_("code",[v._v("routting key")]),v._v("），值为队列名称。")]),v._v(" "),_("li",[v._v("fanout（扇形交换机）：消息将发送到所有绑定在该交换机上的队列，忽略消息的路由键。")]),v._v(" "),_("li",[v._v("direct（直连交换机）：根据消息的路由键（"),_("code",[v._v("routting key")]),v._v("）进行转发。只有当消息的路由键和队列绑定到交换机上的路由键完全匹配时才会进行转发。")]),v._v(" "),_("li",[v._v("topic（主题交换机）：直连交换机的扩展，队列绑定到交换机的路由键（"),_("code",[v._v("routting key")]),v._v("）不仅可以是具体的，也可以是通配符表达式（匹配多个）。")]),v._v(" "),_("li",[v._v("headers（头部交换机）：根据消息的头部属性进行路由。在将队列绑定到交换机时可以声明一个map，消息到达根据消息头和map中的键值进行匹配。\n"),_("ul",[_("li",[v._v("x-match-all: 所有的键值都匹配才能收到消息")]),v._v(" "),_("li",[v._v("x-match-any: 只要有键值匹配就收到消息")])])])]),v._v(" "),_("h2",{attrs:{id:"队列类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列类型"}},[v._v("#")]),v._v(" 队列类型")]),v._v(" "),_("ul",[_("li",[v._v("classic： 在单机环境中，有较高的可靠性。")]),v._v(" "),_("li",[v._v("quorum（仲裁队列）：适用于分布式场景，消息需要集群中多半节点同意确认后，才会写入队列中。")]),v._v(" "),_("li",[v._v("stream：该队列消息是持久化到磁盘中的，适用于分布式场景，适合消费者多，读消息频繁的场景。")])]),v._v(" "),_("h2",{attrs:{id:"工作模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工作模式"}},[v._v("#")]),v._v(" 工作模式")]),v._v(" "),_("p",[_("code",[v._v("RabbitMQ")]),v._v("提供了常见的工作模式，分别为如下：")]),v._v(" "),_("ul",[_("li",[v._v("Simple模式：一个生产者和一个消费值；")]),v._v(" "),_("li",[v._v("Work模式： 一个生产者和多个消费者，共同消费一个队列；")]),v._v(" "),_("li",[v._v("Publish/Subscribe模式： 发布订阅模式，每个消费者可以消费到队列上的全部消息；")]),v._v(" "),_("li",[v._v("Routing模式：消息根据路由键分发到不同的队列中；")]),v._v(" "),_("li",[v._v("Topic模式：拥有模糊匹配的 "),_("code",[v._v("Routing模式")]),v._v("；")])]),v._v(" "),_("h2",{attrs:{id:"生产者消息可靠性投递"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生产者消息可靠性投递"}},[v._v("#")]),v._v(" 生产者消息可靠性投递")]),v._v(" "),_("p",[v._v("保障消息成功发送到队列中：")]),v._v(" "),_("ol",[_("li",[v._v("producer 需要接受到 broker 发送的确认应答。")]),v._v(" "),_("li",[v._v("完善的补偿机制，失败重发")])]),v._v(" "),_("p",[v._v("rabbitmq对于生产端有两层保障，首先是producer 到 exchange， 通过 "),_("code",[v._v("confirmCallback")]),v._v(" 来回执， 其次是 exchange 到\nqueue， 通过 "),_("code",[v._v("returnCallback")]),v._v(" 来回执。")]),v._v(" "),_("p",[v._v("rabbitmq中，"),_("code",[v._v("confirmCallback")]),v._v(" 对于 producer 默认是关闭, 需要进行相应配置进行开启。\nrabbitmq中， "),_("code",[v._v("returnCallback")]),v._v(" 对于 producer 默认也是关闭，在发送消息时， "),_("code",[v._v("mandatory")]),v._v(" 必须开启才能执行 "),_("code",[v._v("returnCallback")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"消费值消息可靠性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消费值消息可靠性"}},[v._v("#")]),v._v(" 消费值消息可靠性")]),v._v(" "),_("p",[v._v("只要保证消费值在消费消息时异常不丢失即可保证可靠性。")]),v._v(" "),_("p",[v._v("rabbitmq 提供了"),_("code",[v._v("消费者应答机制")]),v._v("来使 broker能够感知 consumer 是否消费成功。")]),v._v(" "),_("p",[v._v("默认情况下 "),_("code",[v._v("消费值应答机制")]),v._v(" 是自动的， 及 broker 将消息推送给 consumer 后便会从队列中删除消息；消费者在消息消费过程中失败了，\n消息就存在丢失情况")])])}),[],!1,null,null,null);_.default=t.exports}}]);