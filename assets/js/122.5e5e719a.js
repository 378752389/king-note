(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{581:function(t,a,s){"use strict";s.r(a);var r=s(3),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[t._v("#")]),t._v(" 缓存击穿")]),t._v(" "),a("h3",{attrs:{id:"情景一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#情景一"}},[t._v("#")]),t._v(" 情景一")]),t._v(" "),a("p",[t._v("背景描述：用户根据卫星角度获取节目列表，请求接口时可以指定多个卫星角度，由于合法的卫星角度有限，对于非法用户可能会指定\n一个不存在的卫星角度，并且会指定多个不存在的卫星角度，此时如果我们按照正常业务逻辑返回，将会导致数据库压力过大，查询大量\n不存在的数据。")]),t._v(" "),a("p",[t._v("方案：处理对策是对卫星角度进行有效性验证，然后限制卫星角度精度，并且将不存在的卫星角度进行空值缓存。")]),t._v(" "),a("h2",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),a("p",[t._v("对于分布式场景中，如果需要使用到事务，我们操作的准则是：先加分布式锁，然后再进行事务操作。")]),t._v(" "),a("p",[t._v("原因：想象这样一个情况，我们在进行库存扣减的时候为了确保线程安全都需要加锁，如果代码逻辑是先开启事务，然后在事务内加锁，读取库存量判断是否充足，然后扣减库存，\n当执行到释放锁的步骤时，此时事务还没有结束，另外一个线程拿到锁，读取库存时仍然是旧的库存值（注意此时第一个线程还没有提交事务），此时就会导致数据不一致。")]),t._v(" "),a("h3",{attrs:{id:"情景一-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#情景一-2"}},[t._v("#")]),t._v(" 情景一")]),t._v(" "),a("p",[t._v("背景描述：在设计优惠券抢购的情形中，通常优惠券有数量限制（存在优惠券表中），然后用户在领取优惠券成功后会插入一条领取记录，\n在这样一个抢购优惠券的设计中，需要进行事务处理。由于存在并发情况，需要进行加锁操作，此时会有一个小冲突。")]),t._v(" "),a("p",[t._v("对于优惠券数量扣减，通常需要加锁操作，而插入领取记录通常是不需要加锁的，如果我们把锁粒度减少，依据之前的准则：事务需要加在分布式锁内。\n这样就冲突了。")]),t._v(" "),a("p",[t._v("此时我们不应该减少锁粒度，优化误解，必须满足准则：事务需要加在分布式锁内。")]),t._v(" "),a("h2",{attrs:{id:"游标分页"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#游标分页"}},[t._v("#")]),t._v(" 游标分页")]),t._v(" "),a("p",[t._v("游标分页主要用于解决深分页的问题。")]),t._v(" "),a("p",[t._v("深翻页：指的是从数据库中访问非常靠后（远离第一页）的分页结果。\n问题：")]),t._v(" "),a("ul",[a("li",[t._v("性能问题：随着页码加深，数据库需要扫描更多数据才能找到结果集。")]),t._v(" "),a("li",[t._v("一致性问题：数据表中记录频繁更新或删除，可能导致前后两次翻页之间的结果出现不一致。（原因是新的数据添加到翻页数据中，导致旧数据挪动到当前翻页中）")])]),t._v(" "),a("h3",{attrs:{id:"性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能问题"}},[t._v("#")]),t._v(" 性能问题")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/378752389/image-bed/main/king-note/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E9%9B%86.png",alt:"分页查询查询数据集"}})]),t._v(" "),a("p",[t._v("分页查询中查询结果需要先查询前110条数据，然后丢弃前100条数据，取后10条数据。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/378752389/image-bed/main/king-note/%E6%B8%B8%E6%A0%87%E6%9F%A5%E8%AF%A2%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E9%9B%86.png",alt:"游标查询查询数据集"}})]),t._v(" "),a("p",[t._v("游标查询种查询结果为跳过id为100的数据，然后从id大于100的数据按序取10条数据。")]),t._v(" "),a("h3",{attrs:{id:"倒序分页一致性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#倒序分页一致性问题"}},[t._v("#")]),t._v(" 倒序分页一致性问题")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/378752389/image-bed/main/king-note/%E5%80%92%E5%BA%8F%E5%88%86%E9%A1%B5%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9F%A5%E8%AF%A2.png",alt:"倒序分页第一次查询"}})]),t._v(" "),a("p",[t._v("倒序分页/游标查询，第一次查询为最后3条数据：5,6,7。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/378752389/image-bed/main/king-note/%E5%80%92%E5%BA%8F%E5%88%86%E9%A1%B5%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9F%A5%E8%AF%A2.png",alt:"倒序分页第二次查询"}})]),t._v(" "),a("p",[t._v("倒序分页查询，第二次查询时由于有数据插入到，导致数据顺序发生变化，查询结果为：3,4,5。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/378752389/image-bed/main/king-note/%E5%80%92%E5%BA%8F%E6%B8%B8%E6%A0%87%E5%88%86%E9%A1%B5%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9F%A5%E8%AF%A2.png",alt:"倒序游标分页第二次查询"}})]),t._v(" "),a("p",[t._v("倒序游标分页查询，由于游标记录了上次查询的记录id，因此及时第二次查询时数据发生变化，也能通过游标定位到正确的位置。")])])}),[],!1,null,null,null);a.default=v.exports}}]);