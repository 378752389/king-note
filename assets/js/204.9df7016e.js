(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{665:function(t,a,v){"use strict";v.r(a);var _=v(3),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[a("strong",[t._v("分布式一致性")])]),t._v(" "),a("p",[t._v("分布式系统通常由异步网络连接的多个节点构成，每个节点有独立的计算和存储，节点之间通过网络通信进行协作。\n分布式一致性指多个节点对某一变量的取值达成一致，一旦达成一致，则变量的本次取值即被确定。")]),t._v(" "),a("p",[t._v("处理分布式一致性需要解决以下2个问题：")]),t._v(" "),a("ul",[a("li",[t._v("数据不能存储在单节点上，否则会出现单点故障")]),t._v(" "),a("li",[t._v("多节点需要保证具有相同的数据")])])]),a("h2",{attrs:{id:"raft角色定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#raft角色定义"}},[t._v("#")]),t._v(" Raft角色定义")]),t._v(" "),a("ul",[a("li",[t._v("领导者：当节点作为领导者时，所有集群接收的数据都将通过他接收，再由他决定对数据的处理。他将和所有其他节点保持一个心跳连接，以维护自己的领导状态。心跳连接通过发送一个个的心跳包实现，如果要对其他节点发出命令，就会将命令和数据携带在心跳包中。")]),t._v(" "),a("li",[t._v("跟随者：当节点作为跟随者时，只会负责执行领导者的决策，或者响应领导者发送过来的心跳包，以显示自己仍处于连接。")]),t._v(" "),a("li",[t._v("候选人：当发现领导者下线之后，跟随者节点会马上转变为候选人，并开始组织竞选，通过拉票的方式竞选成为新一任的领导者。")])]),t._v(" "),a("h2",{attrs:{id:"节点状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点状态"}},[t._v("#")]),t._v(" 节点状态")]),t._v(" "),a("ul",[a("li",[t._v("term：节点当前任期")]),t._v(" "),a("li",[t._v("votedFor：当前节点在当前任期中投票给了哪个节点。如果在选举阶段，则表示该节点投票选举的候选人。如果在任期内，则表示当前任期的领导者。")])]),t._v(" "),a("h2",{attrs:{id:"计时器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计时器"}},[t._v("#")]),t._v(" 计时器")]),t._v(" "),a("p",[t._v("Raft通过定义计数器来控制选举的，主要包含三个计时器：选举超时计时器、投票超时计时器和竞选等待超时计时器。")]),t._v(" "),a("h3",{attrs:{id:"选举超时计数器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选举超时计数器"}},[t._v("#")]),t._v(" 选举超时计数器")]),t._v(" "),a("p",[t._v("领导者会通过周期性地向跟随者发送心跳包来维持自己的统治地位。每个跟随者都会有一个选举超时时间，\n这个时间是随机的（如 150-300 ms），及随机计时器。每次接收到心跳包之后，跟随者都会重置该超时时间。\n如果在超时之前没有收到心跳包，跟随者就会判定领导者已下线，此时跟随者就会转变为候选人，开始准备竞选。")]),t._v(" "),a("h3",{attrs:{id:"投票超时计数器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#投票超时计数器"}},[t._v("#")]),t._v(" 投票超时计数器")]),t._v(" "),a("p",[t._v("当跟随者变成候选人时，会开启投票超时的倒计时，并邀请所有其他节点为自己投票。在倒计时结束之前如果得票超一半节点数，\n候选人就竞选成功。如果到了投票超时时间还没攒够票数，该候选人就会宣告这一轮竞选失败，会等一段时间之后再参与竞选。")]),t._v(" "),a("h3",{attrs:{id:"竞选等待计时器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#竞选等待计时器"}},[t._v("#")]),t._v(" 竞选等待计时器")]),t._v(" "),a("p",[t._v("当候选人选举失败时，会等待一段时间之后再次参与竞选，这段等待时间就是竞选等待超时时间。\n此时其他节点可以参加竞选，也可能已经在竞选了，如果候选人在等待投票超时时间或者竞选等待\n超时时间时其他节点竞选成功，则候选人会马上转变为跟随者跟随该新晋的领导者。")]),t._v(" "),a("h3",{attrs:{id:"超时时间重置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时时间重置"}},[t._v("#")]),t._v(" 超时时间重置")]),t._v(" "),a("ul",[a("li",[t._v("只要跟随者收到请求，就会重置自身的选举超时时间。")]),t._v(" "),a("li",[t._v("其他候选人的投票请求也会重置跟随者选举超时时间，让收到投票单没开始竞选的跟随者不参与竞选。")])]),t._v(" "),a("h2",{attrs:{id:"选举规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选举规则"}},[t._v("#")]),t._v(" 选举规则")]),t._v(" "),a("h3",{attrs:{id:"规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规则"}},[t._v("#")]),t._v(" 规则")]),t._v(" "),a("ol",[a("li",[t._v("每一轮任期中，只会出现一位领导者，或者没有领导者。")]),t._v(" "),a("li",[t._v("当领导者下线之后，集群开始进入新的任期。")]),t._v(" "),a("li",[t._v("任何节点收到任期比自身任期大的请求时，需要马上跟随对方并更新自己的任期。")]),t._v(" "),a("li",[t._v("任何节点收到任期等于自身任期的数据追加请求时，需要马上跟随对方。")]),t._v(" "),a("li",[t._v("在一轮任期的选举中，任何一个节点都只能投给一个候选人。")]),t._v(" "),a("li",[t._v("如果收到任期比自身小的请求直接丢弃，否则必须回复。")])]),t._v(" "),a("h2",{attrs:{id:"数据同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据同步"}},[t._v("#")]),t._v(" 数据同步")]),t._v(" "),a("p",[t._v("在Raft算法中，所有数据同步类似于两阶段提交：")]),t._v(" "),a("ul",[a("li",[t._v("客户端请求写数据，主节点将数据写日志，然后同步数据给从节点，等待从节点响应。")]),t._v(" "),a("li",[t._v("超过半数从节点响应，认为此次写成功，则将数据写磁盘，然后返回给客户端。同时主节点发送提交请求，要求从节点进行数据同步，从节点通过成功返回相应。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);