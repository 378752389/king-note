---
title: mysql理论
permalink: /中间件/mysql/理论/
---


## 互联网公司采用RC级别原因

1. 历史原因

   mysql 主从复制是基于binlog日志进行的，binlog有三种格式：
    * statement： 记录修改的sql
    * row： 记录修改的实际数据
    * mixed： 二者混合使用

   在mysql5.0版本之前，只支持statement格式，而这种格式**RC模式**下存在bug：

| Session1                      | Session2                        |
|-------------------------------|---------------------------------|
| begin                         | begin                           |
| delete from test where id < 6 |                                 |
|                               | insert into test(id) values (3) |
|                               | commit                          |
| commit                        |                                 |

在master上执行的顺序为先删除 id 小于 6 的数据， 然后在插入 id = 3的数据，而在 binlog 通过后 slave 执行的顺序变成了 先执行 插入 id = 3的数据， 然后删除id 小于 6 的数据

2. RR问题

   一、在RR 中 存在间隙锁的 问题， 导致出现**死锁**的概率 比 RC 大的多

| Session1                                 | Session2                                 |
|------------------------------------------|------------------------------------------|
| begin                                    | begin                                    |
| select * from t where id = 9 for update; |                                          |
|                                          | select * from t where id = 9 for update; |
|                                          | insert into user value(7,7,7)            |
| insert into user value(7,7,7)            |                                          |
| commit                                   |                                          |
|                                          | commit                                   |

二、在RR 中 条件 未命中索引 会锁表， 在RC 中， 只会锁行

## MRR

全称： Multi-Range Read
Optimization。普通索引上查到主键id后，然后在根据主键id去聚簇索引中取数据。此处需要进行回表操作，普通索引上取出的数据不一定是按照主键id进行排序的，因此可能会导致大量的随机读。如果可以在回表之前按照主键进行排序，那么回表的时候就可以用顺序IO取代为随机IO。

**MRR 在本质上是一种用空间换时间的算法**。这块内存的大小就由参数 read_rnd_buffer_size 来控制，如果 read_rnd_buffer 满了，就会先把满了的 rowid
排好序去磁盘读取，接着清空，然后再往里面继续放 rowid，直到 read_rnd_buffer 又达到 read_rnd_buffe 配置的上限，如此循环。

**MRR能够提升性能的核心在于，这条查询语句在索引a上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。**

开启mrr

```
set optimizer_switch='mrr=on';
```


## binlog进行数据恢复

相信后端开发的同学在开发过程经常会遇到产品临时修改线上数据的需求，如果手法很稳那么很庆幸可以很快完成任务，很不幸某一天突然手一抖把表里的数据修改错误或者误删了，这个时候你会发现各种问题反馈接踵而来。
此时，需要进行数据恢复。可进行如下操作进行数据恢复

### 查看是否开启了`binlog`

```sql
# 查看是否开启了 binlog 日志功能
show variables like '%log_bin%';

# 新建binlog日志文件
flush logs;

# 查看当前 binlog 文件名字
show master status;

# 查看binlog文件事件
show binlog events in 'binlog.000098';
```

### mariadb开启binlog

```shell
vim /etc/my.cnf

# 在[mysqld]下添加
log-bin=mysql-bin
max-binlog-size=1G
expire_logs_days=90
binlog_format=row
```

### 查询binlog日志

```shell
show master status;

# 查看 binlog 进行日志分片的开始时间，并查询最近的5个日志分片
ll -lt /var/lib/mysql/mysql-bin* | head -n 5;

# 导出2023-06-11 -- 2023-06-12 时间段之间 mysql-bin.000001 文件中 的操作数据  
# （--start-datetime 可以通过通过上面分片文件信息，填写开始时间， --stop-datetime 可以填今天，也可以是下一个分片文件的开始时间）
# 文件中数据内容默认是加密的， --base64-output=decode-rows 可以配置解密； 文件中默认是不展示数据的， 可以通过 --verbose 显示数据修改信息；
mysqlbinlog --base64-output=decode-rows --verbose --database=test --start-datetime="2023-06-11 00:00:00" --stop-datetime="2023-06-12 00:00:00" /var/lib/mysql/mysql-bin.000001 > mysql-binlog.sql


# row 方式进行数据查询

# 查询 t_person 表的插入语句
cat mysql-binlog.sql | grep -A 10 'INSERT INTO `test`.`t_person`'
# 查询 t_person 表的删除语句
cat mysql-binlog.sql | grep -A 10 'INSERT INTO `test`.`t_person`'
# 查询 t_person 表的更新语句
cat mysql-binlog.sql | grep -A 10 'UPDATE `test`.`t_person`'

# statement 方式进行数据查询

# 查询 t_person 表的插入语句
cat mysql-binlog.sql | grep 'insert into t_person'
# 查询 t_person 表的删除语句
cat mysql-binlog5.sql | grep 'delete from t_person' 
# 查询 t_person 表的更新语句
cat mysql-binlog5.sql | grep 'delete from t_person' 
```

## 主从复制

修改mysql配置文件 `/etc/my.cnf`
```shell
[mysqld]
# 默认为127.0.0.1 环回监听，不能远程连接， 需要修改监听地址
bind-address=192.168.1.133
log_bin=mysql-bin
server_id=1
binlog_format="MIXED"
# 从库在做 中继日志 进行数据恢复的时候，插入数据可能已经存在，因此会报错，我们在该处设置为跳过主键重复错误
slave_skip_errors=1062

expire_logs_days=30
max_binlog_size=1G

binlog-ignore=mysql #忽略mysql库
binlog-ignore=information_schema #忽略information_schema库
replicate-do-db=test #要同步的数据库，默认所有库
```

重启主库,并创建从库复制用户
```shell
systemctl restart mariadb

create user 'slaver'@'%' IDENTIFIED  BY '123';

GRANT REPLICATION SLAVE ON *.* TO 'slaver'@'%';

flush privileges;

show master status;
```

重启从库，并跟谁主库
```shell

show slave status;

CHANGE MASTER TO
MASTER_HOST='主机的IP地址',
MASTER_USER='主机用户名',
MASTER_PASSWORD='主机用户名的密码',
MASTER_LOG_FILE='mysql-bin.具体数字',
MASTER_LOG_POS=具体值;

CHANGE MASTER TO
MASTER_HOST='192.168.1.128',
MASTER_USER='slaver',
MASTER_PASSWORD='123',
MASTER_LOG_FILE='mysql-bin.000007',
# 可选MASTER_LOG_POS=具体值;

start slave;
```

> 从库在同步过程中可能出现主键冲突的情况
> 
> 这是因为从库执行 relay_log 时候有一部分数据已经在数据库中了，我们需要忽略这部分内容，可以手动忽略

```shell
# 如果同步过程中有其他错误， 我们需要进行排查， 如果认为这条错误无关紧要，可以通过如下方式进行放行；
stop slave;
set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;
start stave;
show slave status\G;


# 常见的代表性错误

# 1007：数据库已存在，创建数据库失败
# 1008：数据库不存在，删除数据库失败
# 1050：数据表已存在，创建数据表失败
# 1051：数据表不存在，删除数据表失败
# 1054：字段不存在，或程序文件跟数据库有冲突
# 1060：字段重复，导致无法插入
# 1061：重复键名
# 1068：定义了多个主键
# 1094：位置线程ID
# 1146：数据表缺失，请恢复数据库
# 1053：复制过程中主服务器宕机
# 1062：主键冲突 Duplicate entry '%s' for key %d

```
